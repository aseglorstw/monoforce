#!/usr/bin/env python

import matplotlib.pyplot as plt
import torch
import numpy as np
from monoforce.config import Config
from monoforce.models import RigidBodySoftTerrain, State
from monoforce.datasets import MonoDemDataset
from monoforce.vis import setup_visualization, animate_trajectory, draw_coord_frames
from monoforce.control import pose_control
from monoforce.losses import translation_difference, rotation_difference, traj_dist
from monoforce.models import monolayout
from monoforce.transformations import rot2rpy, transform_cloud
from monoforce.segmentation import position
from mayavi import mlab
from tqdm import tqdm


class MonoForce:
    def __init__(self, img: np.ndarray, controls: dict,
                 cfg: Config, model_name=None, vis=False):
        self.cfg = cfg
        self.img_size = img.shape[:2]
        self.img = img
        self.controls = controls
        self.model_name = model_name
        self.load_model()
        self.vis = vis

    def load_model(self):
        if self.model_name == 'monolayout':
            self.models = self.load_monolayout()
        else:
            pass

    def load_monolayout(self):
        H, W = self.img_size
        models = {}
        # load encoder weights
        models["encoder"] = monolayout.Encoder(num_layers=18, img_ht=H, img_wt=W, pretrained=False)
        encoder_path = '../config/weights/monolayout/encoder.pth'
        encoder_dict = torch.load(encoder_path, map_location=self.cfg.device)
        filtered_dict_enc = {k: v for k, v in encoder_dict.items() if k in models["encoder"].state_dict()}
        models["encoder"].load_state_dict(filtered_dict_enc)

        # load decoder weights
        decoder_path = '../config/weights/monolayout/decoder.pth'
        models["decoder"] = monolayout.Decoder(models["encoder"].resnet_encoder.num_ch_enc)
        models["decoder"].load_state_dict(torch.load(decoder_path, map_location=self.cfg.device))
        return models

    def monolayout_inference(self, img):
        with torch.no_grad():
            img_tensor = torch.from_numpy(img).unsqueeze(0)
            features = self.models['encoder'](img_tensor)
            height_pred = self.models['decoder'](features, is_training=True)
        height_pred = height_pred.squeeze().cpu().numpy()
        return height_pred

    def run(self):
        height = self.monolayout_inference(self.img)
        height = height.T

        s0 = State(xyz=torch.tensor([-self.cfg.d_max / 2, 0., 1.], device=self.cfg.device).view(3, 1),
                   rot=torch.eye(3, device=self.cfg.device),
                   vel=torch.tensor([0., 0., 0.], device=self.cfg.device).view(3, 1),
                   omega=torch.tensor([0., 0., 0.], device=self.cfg.device).view(3, 1),
                   device=self.cfg.device)

        """ Create robot-terrain interaction models """
        system = RigidBodySoftTerrain(height=height,
                                      grid_res=self.cfg.grid_res,
                                      friction=self.cfg.friction,
                                      mass=self.cfg.robot_mass,
                                      state=s0,
                                      device=self.cfg.device, use_ode=False,
                                      interaction_model='diffdrive')

        # put models with their params to self.cfg.device
        system = system.to(self.cfg.device)
        s0 = system.state
        tt = self.controls['stamps'].to(self.cfg.device)

        if self.vis:
            states = system.sim(s0, tt)
            """ Set-up visualization """
            vis_cfg = setup_visualization(system=system,
                                          states=states,
                                          cfg=self.cfg)
        """ Navigation loop """
        state = system.state
        dt = (tt[1:] - tt[:-1]).mean()

        pos_x, pos_R, vel_x, vel_omega, forces = state
        pos_x, pos_R, vel_x, vel_omega, forces = [pos_x], [pos_R], [vel_x], [vel_omega], [forces]

        for t in range(len(tt[1:])):
            v, w = self.controls['vel_x'][t], self.controls['vel_omega'][t]

            state[2][0] = v
            state[3][2] = w

            dstate = system.forward(t, state)
            state = state.update(dstate, dt)

            pos_x.append(state[0])
            pos_R.append(state[1])
            vel_x.append(state[2])
            vel_omega.append(state[3])
            forces.append(state[4])

        states = [torch.stack(pos_x), torch.stack(pos_R), torch.stack(vel_x), torch.stack(vel_omega), torch.stack(forces)]

        # visualize trajectory
        if self.vis:
            system.update_trajectory(states=states)
            animate_trajectory(system, vis_cfg)

            mlab.show()


def main():
    cfg = Config()
    cfg.grid_res = 0.1
    cfg.device = 'cuda'
    cfg.d_max = 12.8
    cfg.d_min = 1.

    data_paths = [
        '../data/robingas/data/22-08-12-cimicky_haj/marv/ugv_2022-08-12-15-18-34_trav/',
        '../data/robingas/data/22-08-12-cimicky_haj/marv/ugv_2022-08-12-16-37-03_trav/',
        '../data/robingas/data/22-09-27-unhost/husky/husky_2022-09-27-15-01-44_trav/',
    ]
    data_path = data_paths[0]

    img_mean = np.array([0.42155158, 0.47310572, 0.4750956]) if 'marv' in data_path else np.array([0.4750956, 0.47310572, 0.42155158])
    img_std = np.array([0.29598755, 0.23130926, 0.2212268]) if 'marv' in data_path else np.array([0.2212268, 0.23130926, 0.29598755])
    ds = MonoDemDataset(path=data_path,
                        img_size=(512, 512),
                        img_mean=img_mean,
                        img_std=img_std,
                        cameras=['camera_fisheye_front'],
                        cfg=cfg)
    i = 20
    # i = np.random.choice(range(len(ds)))
    img_norm_CHW = ds[i][0]

    tt = torch.linspace(0., cfg.total_sim_time, cfg.n_samples)
    controls = {
        'stamps': tt,
        'vel_x': 1. * torch.ones(cfg.n_samples),
        # 'vel_omega': -0.1 * torch.ones(cfg.n_samples),
        'vel_omega': -2 * torch.sin(2. * np.pi * tt),
    }

    # show image and controls
    img_vis = ds.get_image(i, 'front')[..., (2, 1, 0)]
    plt.figure(figsize=(20, 10))
    plt.subplot(121)
    plt.axis('off')
    plt.imshow(img_vis)
    plt.subplot(122)
    plt.plot(controls['stamps'], controls['vel_x'], label='v(t)')
    plt.plot(controls['stamps'], controls['vel_omega'], label='w(t)')
    plt.xlabel('t [s]')
    plt.ylabel('v [m/s], w [rad/s]')
    plt.grid()
    plt.legend()
    plt.show()

    eval = MonoForce(img=img_norm_CHW,
                     controls=controls,
                     cfg=cfg,
                     model_name='monolayout',
                     vis=True)
    eval.run()


if __name__ == '__main__':
    main()
