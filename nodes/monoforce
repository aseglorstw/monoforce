#!/usr/bin/env python

import os
import torch
import numpy as np
import cv2
import rospy
from cv_bridge import CvBridge
from grid_map_msgs.msg import GridMap
from monoforce.config import Config
from monoforce.models import RigidBodySoftTerrain, State, Geom2Trav
from monoforce.models import monolayout
from monoforce.ros import height_map_to_point_cloud_msg, height_map_to_gridmap_msg
from monoforce.utils import normalize
from sensor_msgs.msg import Image, CompressedImage, PointCloud2
import rospkg


pkg_path = rospkg.RosPack().get_path('monoforce')

class MonoForce:
    def __init__(self, cfg: Config,
                 model_name=None,
                 robot_frame='base_link',
                 img_topic='/camera/image_raw/compressed'):
        self.cfg = cfg
        self.img_size = (512, 512)
        self.model_name = model_name
        rospy.loginfo('Loading model %s' % self.model_name)
        self.load_model()
        self.robot_frame = robot_frame
        # cv bridge
        self.cv_bridge = CvBridge()
        # height map publisher
        self.hm_img_pub = rospy.Publisher('~height_map/image', Image, queue_size=1)
        # point cloud publisher
        self.hm_cloud_pub = rospy.Publisher('~height_map/points', PointCloud2, queue_size=1)
        # grid map publisher
        self.hm_grid_pub = rospy.Publisher('~grid_map', GridMap, queue_size=1)
        # image subscriber
        self.img_sub = rospy.Subscriber(img_topic, CompressedImage, self.img_callback)

    def load_model(self):
        if self.model_name == 'monolayout':
            self.models = self.load_monodem()
        else:
            pass

    def load_monodem(self,
                     encoder_path='config/weights/monolayout/encoder.pth',
                     decoder_path='config/weights/monolayout/decoder.pth',
                     geom2trav_path='config/weights/monolayout/geom2trav.pth'):

        encoder_path = os.path.normpath(os.path.join(pkg_path, encoder_path))
        decoder_path = os.path.normpath(os.path.join(pkg_path, decoder_path))
        geom2trav_path = os.path.normpath(os.path.join(pkg_path, geom2trav_path))

        H, W = self.img_size
        models = {}
        # load encoder weights
        models["encoder"] = monolayout.Encoder(num_layers=18, img_ht=H, img_wt=W, pretrained=False)
        encoder_dict = torch.load(encoder_path, map_location=self.cfg.device)
        filtered_dict_enc = {k: v for k, v in encoder_dict.items() if k in models["encoder"].state_dict()}
        models["encoder"].load_state_dict(filtered_dict_enc)

        # load decoder weights
        models["decoder"] = monolayout.Decoder(models["encoder"].resnet_encoder.num_ch_enc)
        models["decoder"].load_state_dict(torch.load(decoder_path, map_location=self.cfg.device))

        # load geom2trav weights
        if os.path.exists(geom2trav_path):
            print('Loading geom2trav weights from %s' % geom2trav_path)
            models["geom2trav"] = Geom2Trav()
            models["geom2trav"].load_state_dict(torch.load(geom2trav_path, map_location=self.cfg.device))

        # models in eval mode
        for model in models.values():
            if model is not None:
                model.eval()
        return models

    def preprocess_img(self, img_raw):
        # resize image
        H_raw, W_raw = img_raw.shape[:2]
        h, w = self.img_size
        img = cv2.resize(img_raw, (int(h / H_raw * W_raw), h))
        # crop image
        H, W = img.shape[:2]
        img = img[H - h:H, W // 2 - w // 2: W // 2 + w // 2]
        # transpose image
        img = img.transpose((2, 0, 1))  # (H, W, C) -> (C, H, W)
        return img

    def img_callback(self, msg):
        img = self.cv_bridge.compressed_imgmsg_to_cv2(msg)
        img = self.preprocess_img(img)
        height = self.monolayout_inference(img)
        rospy.loginfo('Height map shape: %s' % str(height.shape))

        # publish image
        height_uint8 = np.asarray(255 * normalize(height), dtype='uint8')
        img_msg = self.cv_bridge.cv2_to_imgmsg(height_uint8, encoding='mono8')
        img_msg.header.stamp = msg.header.stamp
        img_msg.header.frame_id = self.robot_frame
        self.hm_img_pub.publish(img_msg)

        # rotate 180 deg because in the image the lower pixels (with height row number) are closer
        height = np.rot90(height, k=2).copy()
        # publish point cloud
        h, w = np.asarray(height.shape) * self.cfg.grid_res
        cloud_msg = height_map_to_point_cloud_msg(height, self.cfg.grid_res,
                                                  xyz=np.array([h / 2., 0, 0]), q=np.array([0., 0., 0., 1.]))
        cloud_msg.header.stamp = msg.header.stamp
        cloud_msg.header.frame_id = self.robot_frame
        self.hm_cloud_pub.publish(cloud_msg)
        # publish grid map
        grid_msg = height_map_to_gridmap_msg(height, self.cfg.grid_res,
                                             xyz=np.array([h / 2., 0, 0]), q=np.array([0., 0., 0., 1.]))
        grid_msg.info.header.stamp = msg.header.stamp
        grid_msg.info.header.frame_id = self.robot_frame
        self.hm_grid_pub.publish(grid_msg)

    def monolayout_inference(self, img, debug=False):
        with torch.no_grad():
            img_tensor = torch.from_numpy(img).unsqueeze(0)
            features = self.models['encoder'](img_tensor)
            height_pred = self.models['decoder'](features, is_training=True)
        height_pred = height_pred.squeeze().cpu().numpy()

        return height_pred


def main():
    cfg = Config()
    cfg.grid_res = 0.1
    cfg.device = 'cuda'
    cfg.d_max = 12.8
    cfg.d_min = 1.

    rospy.init_node('monoforce', anonymous=True, log_level=rospy.DEBUG)
    img_topic = rospy.get_param('~img_topic')
    robot_frame = rospy.get_param('~robot_frame')
    node = MonoForce(cfg=cfg, model_name='monolayout', img_topic=img_topic, robot_frame=robot_frame)
    rospy.spin()


if __name__ == '__main__':
    main()