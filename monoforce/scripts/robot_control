#!/usr/bin/env python

import os
import torch
import numpy as np
from monoforce.config import DPhysConfig
from monoforce.models.dphysics import dphysics, rigid_body_params
from monoforce.datasets import RobinGasBase, robingas_seq_paths
from monoforce.control import pose_control
from monoforce.vis import setup_visualization, animate_trajectory
from mayavi import mlab


cfg = DPhysConfig()
cfg.grid_res = 0.1
cfg.device = 'cpu'
cfg.d_max = 6.4
cfg.d_min = 1.
cfg.max_vel = np.inf
cfg.max_omega = np.inf
cfg.traj_sim_time = 5.0
cfg.dt = 0.01
device = torch.device(cfg.device)


def get_data(i: int = None, path=robingas_seq_paths['husky'][0]):
    """
    Get ground truth data smple from the RobinGas dataset
    :param i: index of the sample
    :param path: path to the dataset
    :return: states_gt, tt_gt, z_grid
    """
    ds = RobinGasBase(path=path, dphys_cfg=cfg)
    if i is None:
        i = np.random.choice(range(len(ds)))
        print('Sample index: %i' % i)

    points, traj, heightmap = ds[i]
    poses = traj['poses']
    tstamps = traj['stamps']
    tstamps = tstamps - tstamps[0]
    z_grid = torch.tensor(heightmap['z'])

    Xs_gt = torch.as_tensor(poses[:, :3, 3])
    Rs_gt = torch.as_tensor(poses[:, :3, :3])

    tt_gt = torch.tensor(tstamps)[None].T

    dps = torch.diff(Xs_gt, dim=0)
    dt = torch.diff(tt_gt, dim=0)
    theta_gt = torch.atan2(dps[:, 1], dps[:, 0]).view(-1, 1)
    theta_gt = torch.cat([theta_gt[:1], theta_gt], dim=0)

    Xds_gt = torch.zeros_like(Xs_gt)
    Xds_gt[:-1] = dps / dt
    Omegas_gt = torch.zeros_like(Xs_gt)
    Omegas_gt[:-1, 2:3] = torch.diff(theta_gt, dim=0) / dt  # + torch.diff(angles_gt, dim=0)[:, 2:3] / dt

    print('Ground truth state shapes:')
    for s in [Xs_gt, Xds_gt, Rs_gt, Omegas_gt]:
        print(s.shape)

    return Xs_gt, Xds_gt, Rs_gt, Omegas_gt, tt_gt, z_grid

def heightmap(d_max, grid_res, mode='zeros'):
    x_grid = torch.arange(-d_max, d_max, grid_res)
    y_grid = torch.arange(-d_max, d_max, grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    if mode == 'zeros':
        z_grid = torch.zeros(x_grid.shape)
    elif mode == 'sin':
        z_grid = torch.sin(x_grid) * torch.cos(y_grid)
    elif mode == 'exp':
        z_grid = torch.exp(-(x_grid) ** 2 / 4) * torch.exp(-(y_grid-2) ** 2 / 2)
    else:
        raise ValueError(f'Invalid mode: {mode}')

    return x_grid, y_grid, z_grid

def motion():
    # simulation parameters
    dt = cfg.dt
    T = cfg.traj_sim_time

    # control inputs in Newtons
    controls = torch.stack([torch.tensor([[110.0, 110.0]] * int(T / dt))])

    # rigid body parameters
    x_points, m, I, mask_left, mask_right = rigid_body_params(from_mesh=False)

    # initial state
    x = torch.tensor([[-2.0, 0.0, 0.5]])
    xd = torch.tensor([[0.0, 0.0, 0.0]])
    R = torch.eye(3).repeat(x.shape[0], 1, 1)
    # R = torch.tensor(Rotation.from_euler('z', [0.0, np.pi/4]).as_matrix(), dtype=torch.float32)
    omega = torch.tensor([[0.0, 0.0, 0.0]])
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)
    xd_points = torch.zeros_like(x_points)
    mask_left = mask_left.repeat(x.shape[0], 1)
    mask_right = mask_right.repeat(x.shape[0], 1)

    # heightmap defining the terrain
    # x_grid, y_grid, z_grid = heightmap(cfg.d_max, cfg.grid_res, mode='exp')
    x_grid = torch.arange(-cfg.d_max, cfg.d_max, cfg.grid_res)
    y_grid = torch.arange(-cfg.d_max, cfg.d_max, cfg.grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    z_grid = get_data(i=327)[-1]
    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid = z_grid.repeat(x.shape[0], 1, 1)

    # initial state
    state0 = (x, xd, R, omega, x_points)

    # simulate the rigid body dynamics
    states, forces = dphysics(state0, xd_points,
                              z_grid, cfg.d_max, cfg.grid_res,
                              m, I, mask_left, mask_right,
                              controls,
                              k_stiffness=5_000,
                              T=T, dt=dt)
    # visualize using mayavi
    for b in range(len(states[0])):
        # get the states and forces for the b-th rigid body and move them to the cpu
        xs, R, xds, omegas, x_points = [s[b].detach().cpu().numpy() for s in states]
        F_spring, F_friction, F_thrust_left, F_thrust_right = [f[b].detach().cpu().numpy() for f in forces]
        x_grid, y_grid, z_grid = [g[b].detach().cpu().numpy() for g in [x_grid, y_grid, z_grid]]
        mask_left, mask_right = mask_left[b].detach().cpu().numpy(), mask_right[b].detach().cpu().numpy()

        # set up the visualization
        vis_cfg = setup_visualization(states=(xs, R, xds, omegas, x_points),
                                      forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                                      x_grid=x_grid, y_grid=y_grid, z_grid=z_grid,
                                      mask_left=mask_left, mask_right=mask_right)

        # visualize animated trajectory
        animate_trajectory(states=(xs, R, xds, omegas, x_points),
                           forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                           z_grid=z_grid, mask_left=mask_left, mask_right=mask_right,
                           vis_cfg=vis_cfg, step=10)

def p_control():
    from monoforce.models.dphysics import forward_kinematics, update_states, vw_to_track_vel
    from monoforce.control import pose_control

    """
    Simulate the system with P control.
    Robot visits a set of waypoints.
    Diff-drive (controlled with X-linear and Z-angular velocities) robot motion model is used.
    """
    # rigid body parameters
    x_points, m, I, mask_left, mask_right = rigid_body_params(from_mesh=False)
    I_inv = torch.inverse(I)

    # get ground truth data
    Xs_gt, Xds_gt, Rs_gt, Omegas_gt, ts_gt, z_grid = get_data()
    d_max = cfg.d_max
    grid_res = cfg.grid_res
    dt = cfg.dt
    k_stiffness = 100.0
    k_damping = torch.sqrt(4 * m * k_stiffness)  # critical damping
    k_friction = 0.5
    x_grid = torch.arange(-d_max, d_max, grid_res)
    y_grid = torch.arange(-d_max, d_max, grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)

    # initial state
    x = torch.tensor([[0.0, 0.0, 0.2]])
    xd = torch.tensor([[0.0, 0.0, 0.0]])
    R = torch.eye(3).repeat(x.shape[0], 1, 1)
    # R = torch.tensor(Rotation.from_euler('z', [0.0, np.pi/4]).as_matrix(), dtype=torch.float32)
    omega = torch.tensor([[0.0, 0.0, 0.0]])
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)
    xd_points = torch.zeros_like(x_points)
    mask_left = mask_left.repeat(x.shape[0], 1)
    mask_right = mask_right.repeat(x.shape[0], 1)

    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid = z_grid.repeat(x.shape[0], 1, 1)

    # put models with their params to cfg.device
    xd_points = xd_points.to(device)
    z_grid = z_grid.to(device)
    I_inv = I_inv.to(device)
    mask_left = mask_left.to(device)
    mask_right = mask_right.to(device)

    # dynamics of the rigid body
    Xs, Xds, Rs, Omegas, Omega_ds, X_points = [], [], [], [], [], []
    F_springs, F_frictions, F_thrusts_left, F_thrusts_right = [], [], [], []
    B, N_ts, N_pts = x.shape[0], len(ts_gt), x_points.shape[1]
    for t in range(len(ts_gt)):
        # control inputs
        pose = torch.eye(4)
        pose[:3, 3] = x.squeeze()
        pose[:3, :3] = R.squeeze()
        pose_gt = torch.eye(4)
        pose_gt[3, :3] = Xs_gt[t]
        pose_gt[:3, :3] = Rs_gt[t]
        v, w, dist = pose_control(pose, pose_gt, return_dist=True)
        u_left, u_right = vw_to_track_vel(v, w)  # convert linear and angular velocities to track velocities

        # forward kinematics
        (xd, xdd, dR, omega_d, xd_points,
         F_spring, F_friction, F_thrust_left, F_thrust_right) = forward_kinematics(x, xd, R, omega, x_points, xd_points,
                                                                                   z_grid, d_max, grid_res,
                                                                                   m, I_inv, mask_left, mask_right,
                                                                                   k_stiffness, k_damping, k_friction,
                                                                                   u_left, u_right)
        # update states: integration steps
        x, xd, R, omega, x_points = update_states(x, xd, xdd, R, dR, omega, omega_d, x_points, xd_points, dt)

        # save states
        Xs.append(x)
        Xds.append(xd)
        Rs.append(R)
        Omegas.append(omega)
        X_points.append(x_points)

        # save forces
        F_springs.append(F_spring)
        F_frictions.append(F_friction)
        F_thrusts_left.append(F_thrust_left)
        F_thrusts_right.append(F_thrust_right)

    # to tensors
    Xs = torch.stack(Xs).transpose(1, 0)
    assert Xs.shape == (B, N_ts, 3)
    Xds = torch.stack(Xds).transpose(1, 0)
    assert Xds.shape == (B, N_ts, 3)
    Rs = torch.stack(Rs).transpose(1, 0)
    assert Rs.shape == (B, N_ts, 3, 3)
    Omegas = torch.stack(Omegas).transpose(1, 0)
    assert Omegas.shape == (B, N_ts, 3)
    X_points = torch.stack(X_points).transpose(1, 0)
    assert X_points.shape == (B, N_ts, N_pts, 3)
    F_springs = torch.stack(F_springs).transpose(1, 0)
    assert F_springs.shape == (B, N_ts, N_pts, 3)
    F_frictions = torch.stack(F_frictions).transpose(1, 0)
    assert F_frictions.shape == (B, N_ts, N_pts, 3)
    F_thrusts_left = torch.stack(F_thrusts_left).transpose(1, 0)
    assert F_thrusts_left.shape == (B, N_ts, 3)
    F_thrusts_right = torch.stack(F_thrusts_right).transpose(1, 0)
    assert F_thrusts_right.shape == (B, N_ts, 3)

    states = Xs, Xds, Rs, Omegas, X_points
    forces = F_springs, F_frictions, F_thrusts_left, F_thrusts_right

    # visualize using mayavi
    for b in range(len(states[0])):
        # get the states and forces for the b-th rigid body and move them to the cpu
        xs, R, xds, omegas, x_points = [s[b].detach().cpu().numpy() for s in states]
        F_spring, F_friction, F_thrust_left, F_thrust_right = [f[b].detach().cpu().numpy() for f in forces]
        x_grid, y_grid, z_grid = [g[b].detach().cpu().numpy() for g in [x_grid, y_grid, z_grid]]
        mask_left, mask_right = mask_left[b].detach().cpu().numpy(), mask_right[b].detach().cpu().numpy()

        # set up the visualization
        vis_cfg = setup_visualization(states=(xs, R, xds, omegas, x_points),
                                      forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                                      x_grid=x_grid, y_grid=y_grid, z_grid=z_grid,
                                      mask_left=mask_left, mask_right=mask_right)

        # visualize animated trajectory
        animate_trajectory(states=(xs, R, xds, omegas, x_points),
                           forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                           z_grid=z_grid, mask_left=mask_left, mask_right=mask_right,
                           vis_cfg=vis_cfg)


def main():
    motion()
    # p_control()


if __name__ == '__main__':
    main()
