#!/usr/bin/env python
from copy import deepcopy
from rosbag import Compression, Bag
from tqdm import tqdm
from monoforce.datasets import robingas_husky_seq_paths
import numpy as np
from scipy.spatial.transform import Rotation
from tf.transformations import quaternion_from_matrix, quaternion_matrix
from geometry_msgs.msg import Transform

paths = robingas_husky_seq_paths

for path in paths:
    input_bag_path = path + '.bag'
    print('Processing', input_bag_path)
    output_bag_path = input_bag_path[:-4] + '_new.bag'
    print('Saving to', output_bag_path)

    # tf_buffer = load_tf_buffer([input_bag_path])
    camera_frames = ['camera_0', 'camera_1', 'camera_2', 'camera_3']
    Tr_fix = np.eye(4)
    R = Rotation.from_euler('x', -np.pi / 2, degrees=False).as_matrix()
    Tr_fix[:3, :3] = R

    input_bag = Bag(input_bag_path)
    with Bag(output_bag_path, 'w', compression=Compression.LZ4) as output_bag:
        for topic, msg, t in tqdm(input_bag.read_messages(), total=input_bag.get_message_count()):
            # get transformation from camera frame to its parent frame
            if topic == '/tf_static':
                for i, m in enumerate(msg.transforms):  # go through each frame->frame tf within the msg.transforms
                    if m.child_frame_id in camera_frames:
                        print('Changing transformation from', m.child_frame_id, 'to', m.header.frame_id)
                        m_new = deepcopy(m)

                        if m.child_frame_id == 'camera_0':
                            m_new.child_frame_id = 'camera_3'
                        elif m.child_frame_id == 'camera_1':
                            m_new.child_frame_id = 'camera_0'
                        elif m.child_frame_id == 'camera_2':
                            m_new.child_frame_id = 'camera_1'
                        elif m.child_frame_id == 'camera_3':
                            m_new.child_frame_id = 'camera_2'

                        Tr = np.eye(4)
                        q = [m.transform.rotation.x, m.transform.rotation.y, m.transform.rotation.z, m.transform.rotation.w]
                        Tr[:3, :3] = quaternion_matrix(q)[:3, :3]
                        Tr[:3, 3] = [m.transform.translation.x, m.transform.translation.y, m.transform.translation.z]

                        Tr_new = Tr @ Tr_fix
                        tf_new = Transform()
                        tf_new.translation.x = Tr_new[0, 3]
                        tf_new.translation.y = Tr_new[1, 3]
                        tf_new.translation.z = Tr_new[2, 3]
                        q_new = quaternion_from_matrix(Tr_new)
                        tf_new.rotation.x = q_new[0]
                        tf_new.rotation.y = q_new[1]
                        tf_new.rotation.z = q_new[2]
                        tf_new.rotation.w = q_new[3]
                        m_new.transform = tf_new

                        msg.transforms[i] = m_new
            output_bag.write(topic, msg, t)
    print('Done')