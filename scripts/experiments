#! /usr/bin/env python3
import os
import torch
from pytorch3d.loss import chamfer_distance
from pytorch3d.structures import Meshes, Pointclouds
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader
from tqdm import tqdm
from monoforce.cloudproc import hm_to_cloud, filter_grid, filter_box
from monoforce.datasets import rellis3d_seq_paths
from monoforce.datasets.robingas import RobinGas, explore_data, DEMPathData, RobinGasCamSynch
from monoforce.datasets.robingas import robingas_husky_seq_paths, oru_seq_paths
from monoforce.config import DPhysConfig
from monoforce.models.lss.tools import denormalize_img
from monoforce.transformations import transform_cloud
from monoforce.utils import read_yaml, position
from monoforce.models.lss.model import compile_model
import open3d as o3d
from scipy import interpolate
from scipy.spatial.transform import Rotation
from scipy.spatial.transform import Slerp
from scipy.spatial import cKDTree
from monoforce.vis import draw_coord_frame, draw_coord_frames
from mayavi import mlab


def feed_data():
    # path = '/media/ruslan/data/husky_sim/husky_back_forth_rigid_soft_cubes_2024-02-15-15-07-56/'
    # path = '/media/ruslan/data/husky_sim/husky_cubes_random_walk_2024-02-12-15-08-00/'
    path = robingas_husky_seq_paths[1]

    # lss model
    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    # load LSS config
    lss_config = read_yaml('../config/lss_cfg.yaml')
    grid_conf, data_aug_conf = lss_config['grid_conf'], lss_config['data_aug_conf']

    ds = RobinGas(path, data_aug_conf, is_train=False, dphys_cfg=cfg)
    model = compile_model(grid_conf, data_aug_conf, outC=1)
    model.train()
    model.to(cfg.device)

    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
    max_grad_norm = 5.0

    def criterion(height_pred, height_gt, weights=None):
        if weights is None:
            weights = torch.ones_like(height_gt)
        return torch.mean(weights * (height_pred - height_gt) ** 2)

    # train on a single example
    sample_i = np.random.randint(len(ds))
    # sample_i = 64
    print('Sample index:', sample_i)
    explore_data(path, grid_conf, data_aug_conf, cfg, is_train=False, sample_range=[sample_i])
    imgs, rots, trans, intrins, post_rots, post_trans, hm_lidar, hm_traj, map_pose = ds[sample_i]
    inputs = [imgs, rots, trans, intrins, post_rots, post_trans]
    inputs = [s[np.newaxis].to(cfg.device) for s in inputs]

    hm_lidar = torch.as_tensor(hm_lidar[np.newaxis], device=cfg.device)
    height_lidar, mask_lidar = hm_lidar[:, 0:1], hm_lidar[:, 1:2]

    hm_traj = torch.as_tensor(hm_traj[np.newaxis], device=cfg.device)
    height_traj, mask_traj = hm_traj[:, 0:1], hm_traj[:, 1:2]

    losses = {'lidar': [], 'traj': [], 'total': [], 'hdiff': []}
    n_iters = 1001
    vis_step = 50
    for i in tqdm(range(n_iters)):
        voxel_feats = model.get_voxels(*inputs)
        height_pred_geom, height_pred_diff = model.bevencode(voxel_feats)
        height_pred_rigid = height_pred_geom - height_pred_diff

        weights_obstacles = 1.0 + torch.abs(height_lidar[mask_lidar.bool()] - height_lidar[mask_lidar.bool()].mean())
        loss_lidar = criterion(height_pred_geom[mask_lidar.bool()], height_lidar[mask_lidar.bool()], weights_obstacles)
        loss_traj = 10.*criterion(height_pred_rigid[mask_traj.bool()], height_traj[mask_traj.bool()])
        loss_hdif = 1e-4*height_pred_diff.std()

        loss = loss_lidar + loss_traj + loss_hdif

        print('loss lidar: %f, loss traj: %f, loss reg: %f, total loss: %f' %
              (loss_lidar.item(), loss_traj.item(), loss_hdif.item(), loss.item()))
        losses['lidar'].append(loss_lidar.item())
        losses['traj'].append(loss_traj.item())
        losses['hdiff'].append(loss_hdif.item())
        losses['total'].append(loss.item())

        optimizer.zero_grad()
        loss.backward()
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_grad_norm)
        optimizer.step()

        if i % vis_step == 0:
            # plot the result
            plt.figure(figsize=(20, 10))
            plt.subplot(2, 3, 1)
            plt.title('Lidar HM')
            plt.imshow(height_lidar[0, 0].cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 2)
            plt.title('Traj HM')
            plt.imshow(height_traj[0, 0].cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 3)
            plt.title('Loss')
            for k, v in losses.items():
                plt.plot(v[-vis_step:], label=k)
            plt.legend()

            plt.subplot(2, 3, 4)
            plt.title('Prediction Geom')
            plt.imshow(height_pred_geom[0, 0].detach().cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 5)
            plt.title('Prediction Diff')
            plt.imshow(height_pred_diff[0, 0].detach().cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 6)
            plt.title('Prediction Rigid')
            plt.imshow(height_pred_rigid[0, 0].detach().cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.show()
            plt.close()


def map_consistency():
    cfg_path = '../config/tb_runs/lss_2024_01_26_15_07_31/dphys_cfg.yaml'
    lss_cfg_path = '../config/tb_runs/lss_2024_01_26_15_07_31/lss_cfg.yaml'
    model_path = '../config/tb_runs/lss_2024_01_26_15_07_31/train_lss.pt'

    cfg = DPhysConfig()
    cfg.from_yaml(cfg_path)
    cfg.hm_interp_method = None
    cfg.device = 'cuda'

    predicted_map = True
    vis = True

    lss_cfg = read_yaml(lss_cfg_path)
    data_aug_conf = lss_cfg['data_aug_conf']
    grid_conf = lss_cfg['grid_conf']

    ds = RobinGas(robingas_husky_seq_paths[0], is_train=True, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
    loader = DataLoader(ds, batch_size=16, shuffle=False)
    # ds.global_cloud(vis=True)
    ds.global_hm_cloud(vis=True)

    model = compile_model(grid_conf, data_aug_conf, outC=1)
    model.load_state_dict(torch.load(model_path))
    model.eval()
    model.to(cfg.device)

    # create global heightmap
    for batch in tqdm(loader):
        with torch.no_grad():
            batch = [torch.as_tensor(b, dtype=torch.float32, device=cfg.device) for b in batch]
            imgs, rots, trans, intrins, post_rots, post_trans, hm_lidar, hm_traj, map_pose = batch

            if predicted_map:
                inputs = [imgs, rots, trans, intrins, post_rots, post_trans]
                height_pred = model(*inputs)
                height = height_pred
                # mask = torch.ones_like(height)
                mask = hm_lidar[:, 1:2]
            else:
                height = hm_lidar[:, 0:1]
                mask = hm_lidar[:, 1:2]

            global_hm_clouds = []
            for p, h, m in zip(map_pose, height, mask):
                hm_cloud = hm_to_cloud(h.squeeze(), cfg, mask=m.squeeze())
                hm_cloud = transform_cloud(hm_cloud, p)
                global_hm_clouds.append(hm_cloud)

            # pytorch3d pointcloud
            src_cloud = Pointclouds(points=[torch.cat(global_hm_clouds[::2])])
            tgt_cloud = Pointclouds(points=[torch.cat(global_hm_clouds[1::2])])
            # chamfer distance
            chamfer_dist, _ = chamfer_distance(src_cloud, tgt_cloud)
            print('Chamfer distance:', chamfer_dist)

            if vis:
                global_hm_cloud = torch.cat(global_hm_clouds, dim=0)
                # plot global cloud with open3d
                hm_pcd = o3d.geometry.PointCloud()
                hm_pcd.points = o3d.utility.Vector3dVector(global_hm_cloud.cpu().numpy())
                o3d.visualization.draw_geometries([hm_pcd])


def data_slicing():
    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']
    grid_conf = lss_cfg['grid_conf']

    ds = RobinGas(robingas_husky_seq_paths[0], is_train=True, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
    ds_slice = ds[150:200]
    print("Full dataset contains samples", ds.ids)
    print("Sliced dataset contains samples", ds_slice.ids)
    # check if sliced dataset indixes is a subset of full dataset indixes
    assert set(ds_slice.ids).issubset(set(ds.ids))
    ds_slice.global_hm_cloud(vis=True)


def create_global_gloud_map():
    """
    Create global heightmap cloud from the sequence of point clouds
    """
    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']

    for path in robingas_husky_seq_paths:
        print('Processing sequence:', path)
        ds = RobinGas(path, is_train=True, data_aug_conf=data_aug_conf, dphys_cfg=cfg)

        # create global cloud
        poses = ds.get_poses()
        dist_th = 0.1
        global_cloud = None
        for i in tqdm(range(len(ds))):
            cloud = ds.get_cloud(i)
            T = poses[i]
            cloud = transform_cloud(cloud, T)
            points = position(cloud)
            points = filter_grid(points, ds.dphys_cfg.grid_res, keep='first', log=False)
            if i == 0:
                global_cloud = points
            else:
                tree = cKDTree(global_cloud)
                dists, idxs = tree.query(points, k=1)
                new_pts_mask = dists > dist_th
                new_points = points[new_pts_mask]
                global_cloud = np.vstack((global_cloud, new_points))

        # visualize global cloud
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(global_cloud)

        pcd_poses = o3d.geometry.PointCloud()
        pcd_poses.points = o3d.utility.Vector3dVector(poses[:, :3, 3])
        pcd_poses.paint_uniform_color([1, 0, 0])

        # save global cloud
        o3d.io.write_point_cloud(os.path.join(path, 'global_map.pcd'), pcd)
        o3d.visualization.draw_geometries([pcd, pcd_poses])

def visualize_point_cloud_map():
    """
    Visualize point cloud map and trajectory point cloud
    """
    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']

    paths = robingas_husky_seq_paths
    # paths = oru_seq_paths

    for path in paths:
        ds = RobinGas(path, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
        poses = ds.get_poses()

        map_path = os.path.join(path, 'global_map.pcd')
        assert os.path.exists(map_path)
        pcd = o3d.io.read_point_cloud(map_path)
        # pcd = o3d.geometry.PointCloud()
        # map_points = ds.global_cloud(vis=False)
        # pcd.points = o3d.utility.Vector3dVector(map_points)

        pcd_poses = o3d.geometry.PointCloud()
        pcd_poses.points = o3d.utility.Vector3dVector(poses[:, :3, 3])
        pcd_poses.paint_uniform_color([1, 0, 0])

        o3d.visualization.draw_geometries([pcd, pcd_poses])


def interpolate_poses(pose_timestamps, abs_poses, requested_timestamps, origin_timestamp):
    """Interpolate between absolute poses.

    Args:
        pose_timestamps (list[int]): Timestamps of supplied poses. Must be in ascending order.
        abs_poses (list[numpy.matrixlib.defmatrix.matrix]): SE3 matrices representing poses at the timestamps specified.
        requested_timestamps (list[int]): Timestamps for which interpolated timestamps are required.
        origin_timestamp (int): UNIX timestamp of origin frame. Poses will be reported relative to this frame.

    Returns:
        list[numpy.matrixlib.defmatrix.matrix]: Interpolated poses at the requested timestamps.
    """
    if len(pose_timestamps) != len(abs_poses):
        raise ValueError('pose_timestamps and abs_poses must be the same length')

    if pose_timestamps != sorted(pose_timestamps):
        raise ValueError('pose_timestamps must be in ascending order')

    # convert to numpy array
    pose_timestamps = np.asarray(pose_timestamps)
    abs_poses = np.asarray(abs_poses)

    # convert to relative timestamps
    rel_timestamps = pose_timestamps - origin_timestamp
    requested_timestamps = np.asarray(requested_timestamps) - origin_timestamp

    # interpolate using spherical linear interpolation
    slerp = Slerp(rel_timestamps, Rotation.from_matrix(abs_poses[:, :3, :3]))
    interp_rotations = slerp(requested_timestamps)

    # interpolate translations
    interp_translations = []
    for i in range(3):
        interp_translations.append(interpolate.interp1d(pose_timestamps, abs_poses[:, i, 3])(requested_timestamps))

    interp_poses = []
    for r, t in zip(interp_rotations, interp_translations):
        pose = np.eye(4)
        pose[:3, :3] = r.as_matrix()
        pose[:3, 3] = t
        interp_poses.append(pose)

    return interp_poses


def check_interpolate_poses():
    from monoforce.vis import draw_coord_frame, draw_coord_frames
    from mayavi import mlab

    pose_timestamps = np.arange(0, 10, 1).tolist()

    pose0 = np.eye(4)
    abs_poses = [pose0]
    for i in range(1, len(pose_timestamps)):
        # pose = np.eye(4)
        # pose[:3, 3] += i * np.asarray([1, 0, 0])
        # pose[:3, :3] = Rotation.from_euler('xyz', [0, 0, i * np.pi / 4]).as_matrix()

        # spiral trajectory
        pose = np.eye(4)
        pose[:3, 3] += i * np.asarray([np.cos(i), np.sin(i), 1.])
        pose[:3, :3] = Rotation.from_euler('xyz', [0, 0, i * np.pi / len(pose_timestamps)]).as_matrix()

        abs_poses.append(pose)
    abs_poses = np.asarray(abs_poses)

    requested_timestamps = np.arange(0.5, 9.5, 1).tolist()
    print('Pose timestamps:', pose_timestamps)
    print('Requested timestamps:', requested_timestamps)
    # print('Absolute poses', abs_poses)

    origin_timestamp = 0.
    interp_poses = interpolate_poses(pose_timestamps, abs_poses, requested_timestamps, origin_timestamp)
    interp_poses = np.asarray(interp_poses)
    print('Interpolated poses', interp_poses)

    # visualize
    draw_coord_frames(abs_poses, scale=0.2)
    draw_coord_frames(interp_poses, scale=0.1)
    mlab.show()


def vis_camera_poses():
    for path in robingas_husky_seq_paths:
        assert os.path.exists(path)

        cfg = DPhysConfig()
        ds = DEMPathData(path, dphys_cfg=cfg)

        robot_pose = np.eye(4)
        robot_frame = 'base_link'
        camera_frames = ['camera_left', 'camera_right', 'camera_front', 'camera_rear']

        cam_poses = []
        for cam_frame in camera_frames:

            T_robot_cam = ds.calib['transformations'][f'T_{robot_frame}__{cam_frame}']['data']
            T_robot_cam = np.asarray(T_robot_cam, dtype=np.float32).reshape((4, 4))

            cam_poses.append(T_robot_cam[np.newaxis])
        cam_poses = np.concatenate(cam_poses, axis=0)

        # draw coordinate frames
        mlab.figure(size=(800, 800))
        draw_coord_frame(robot_pose, scale=0.5)
        draw_coord_frames(cam_poses, scale=0.1)
        mlab.show()


def vis_trajectory():
    from monoforce.losses import translation_difference, rotation_difference

    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']

    paths = robingas_husky_seq_paths
    # paths = oru_seq_paths

    for path in paths:
        ds = RobinGas(path, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
        poses = ds.get_poses()
        cam_poses = ds.get_poses_at_camera_stamps('camera_front')
        assert len(poses) == len(cam_poses)
        trans_diff = translation_difference(torch.as_tensor(poses[:, :3, 3:4]), torch.as_tensor(cam_poses[:, :3, 3:4]))
        rot_diff = rotation_difference(torch.as_tensor(poses[:, :3, :3]), torch.as_tensor(cam_poses[:, :3, :3]))
        print('Translation difference:', trans_diff)
        print('Rotation difference:', rot_diff)

        mlab.figure(size=(800, 800))
        draw_coord_frames(poses[::5], scale=0.5)
        draw_coord_frames(cam_poses[::5], scale=1)
        mlab.show()


def sample_heightmap_at_img_pose():
    cfg = DPhysConfig()
    cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']

    path = robingas_husky_seq_paths[0]

    ds_synch = RobinGasCamSynch(path, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
    # global_cloud = ds_synch.global_cloud(vis=False)

    i = np.random.choice(len(ds_synch))
    cloud_synch = ds_synch.get_cloud(i)

    ds = RobinGas(path, data_aug_conf=data_aug_conf, dphys_cfg=cfg)
    cloud = ds.get_cloud(i)
    cloud = position(cloud)

    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(cloud)
    pcd.paint_uniform_color([0, 0, 1])

    pcd_synch = o3d.geometry.PointCloud()
    pcd_synch.points = o3d.utility.Vector3dVector(cloud_synch)
    pcd_synch.paint_uniform_color([1, 0, 0])

    o3d.visualization.draw_geometries([pcd, pcd_synch])


def vis_data():
    from monoforce.datasets import RobinGas, Rellis3D

    dphys_cfg = DPhysConfig()
    dphys_cfg.from_yaml('../config/dphys_cfg.yaml')

    lss_cfg = read_yaml('../config/lss_cfg.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']

    # paths = robingas_husky_seq_paths
    # paths = rellis3d_seq_paths
    paths = oru_seq_paths + robingas_husky_seq_paths

    for path in paths:
        ds = RobinGas(path=path, dphys_cfg=dphys_cfg, data_aug_conf=data_aug_conf, is_train=False, only_front_hm=True)
        # ds = Rellis3D(path=path, dphys_cfg=dphys_cfg, data_aug_conf=data_aug_conf, is_train=False)
        i = np.random.choice(range(len(ds)))
        print(f'Visualizing sample {i} from {os.path.basename(path)}...')

        img, rot, tran, intrin, post_rot, post_tran, hm_lidar, hm_traj, map_pose = ds[i]
        img = denormalize_img(img[0])

        height_lidar, weights_lidar = hm_lidar[0], hm_lidar[1]
        height_traj, weights_traj = hm_traj[0], hm_traj[1]

        plt.figure(figsize=(20, 4))
        plt.subplot(1, 5, 1)
        plt.title('Front (0) Image')
        plt.imshow(img)
        plt.subplot(1, 5, 2)
        plt.title('Height Trajectory')
        plt.imshow(height_traj.squeeze().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
        plt.subplot(1, 5, 3)
        plt.title('Weights Trajectory')
        plt.imshow(weights_traj.squeeze().T, alpha=0.5, cmap='gray', origin='lower')
        plt.subplot(1, 5, 4)
        plt.title('Height Lidar')
        plt.imshow(height_lidar.squeeze().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
        plt.subplot(1, 5, 5)
        plt.title('Weights Lidar')
        plt.imshow(weights_lidar.squeeze().T, alpha=0.5, cmap='gray', origin='lower')

        plt.show()


def main():
    # feed_data()
    # map_consistency()
    # data_slicing()
    # visualize_point_cloud_map()
    # create_global_gloud_map()
    # check_interpolate_poses()
    # vis_camera_poses()
    # vis_trajectory()
    # sample_heightmap_at_img_pose()
    vis_data()


if __name__ == '__main__':
    main()
