#!/usr/bin/env python

import torch
import numpy as np
from monoforce.config import DPhysConfig
from monoforce.models.dphysics import dphysics
from monoforce.datasets import RobinGasBase, robingas_seq_paths
from monoforce.vis import setup_visualization, animate_trajectory


# rigid body and terrain parameters
dphys_cfg = DPhysConfig()
dphys_cfg.grid_res = 0.1
dphys_cfg.device = 'cpu'
dphys_cfg.d_max = 6.4
dphys_cfg.d_min = 1.
dphys_cfg.traj_sim_time = 5.0
dphys_cfg.dt = 0.01
device = torch.device(dphys_cfg.device)


def get_data(i: int = None, path=robingas_seq_paths['husky'][0]):
    """
    Get ground truth data smple from the RobinGas dataset
    :param i: index of the sample
    :param path: path to the dataset
    :return: states_gt, tt_gt, z_grid
    """
    ds = RobinGasBase(path=path, dphys_cfg=dphys_cfg)
    if i is None:
        i = np.random.choice(range(len(ds)))
        print('Sample index: %i' % i)

    points, traj, heightmap = ds[i]
    poses = traj['poses']
    tstamps = traj['stamps']
    tstamps = tstamps - tstamps[0]
    z_grid = torch.tensor(heightmap['z'])

    Xs_gt = torch.as_tensor(poses[:, :3, 3])
    Rs_gt = torch.as_tensor(poses[:, :3, :3])

    tt_gt = torch.tensor(tstamps)[None].T

    dps = torch.diff(Xs_gt, dim=0)
    dt = torch.diff(tt_gt, dim=0)
    theta_gt = torch.atan2(dps[:, 1], dps[:, 0]).view(-1, 1)
    theta_gt = torch.cat([theta_gt[:1], theta_gt], dim=0)

    Xds_gt = torch.zeros_like(Xs_gt)
    Xds_gt[:-1] = dps / dt
    Omegas_gt = torch.zeros_like(Xs_gt)
    Omegas_gt[:-1, 2:3] = torch.diff(theta_gt, dim=0) / dt  # + torch.diff(angles_gt, dim=0)[:, 2:3] / dt

    print('Ground truth state shapes:')
    for s in [Xs_gt, Xds_gt, Rs_gt, Omegas_gt]:
        print(s.shape)

    return Xs_gt, Xds_gt, Rs_gt, Omegas_gt, tt_gt, z_grid

def heightmap(d_max, grid_res, mode='zeros'):
    x_grid = torch.arange(-d_max, d_max, grid_res)
    y_grid = torch.arange(-d_max, d_max, grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    if mode == 'zeros':
        z_grid = torch.zeros(x_grid.shape)
    elif mode == 'sin':
        z_grid = torch.sin(x_grid) * torch.cos(y_grid)
    elif mode == 'exp':
        z_grid = torch.exp(-(x_grid - 2) ** 2 / 4) * torch.exp(-y_grid ** 2 / 2)
    else:
        raise ValueError(f'Invalid mode: {mode}')

    return x_grid, y_grid, z_grid

def motion():
    # simulation parameters
    dt = dphys_cfg.dt
    T = dphys_cfg.traj_sim_time

    # control inputs in Newtons
    controls = dphys_cfg.k_thrust * torch.stack([torch.tensor([[1.0, 1.0]] * int(T / dt)),
                                                        torch.tensor([[-1.0, -1.0]] * int(T / dt)),
                                                        ], dim=0)

    # initial state
    x = torch.tensor([[-2.0, 0.0, 0.5], [4.0, 0.0, 0.5]], dtype=torch.float32)
    xd = torch.zeros_like(x)
    R = torch.eye(3).repeat(x.shape[0], 1, 1)
    # R = torch.tensor(Rotation.from_euler('z', [0.0, np.pi/4]).as_matrix(), dtype=torch.float32)
    omega = torch.zeros_like(x)
    x_points = dphys_cfg.robot_points.repeat(x.shape[0], 1, 1)
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)
    state0 = (x, xd, R, omega, x_points)

    # rigid body geometry
    mask_left = dphys_cfg.robot_mask_left.repeat(x.shape[0], 1)
    mask_right = dphys_cfg.robot_mask_right.repeat(x.shape[0], 1)

    # heightmap defining the terrain
    x_grid, y_grid, z_grid = heightmap(dphys_cfg.d_max, dphys_cfg.grid_res, mode='exp')
    # x_grid = torch.arange(-cfg.d_max, cfg.d_max, cfg.grid_res)
    # y_grid = torch.arange(-cfg.d_max, cfg.d_max, cfg.grid_res)
    # x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    # z_grid = get_data(i=327)[-1]
    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid = z_grid.repeat(x.shape[0], 1, 1)

    # simulate the rigid body dynamics
    states, forces = dphysics(z_grid=z_grid, controls=controls,
                              state=state0,
                              dphys_cfg=dphys_cfg)

    # visualize using mayavi
    for b in range(len(states[0])):
        # get the states and forces for the b-th rigid body and move them to the cpu
        xs, R, xds, omegas, x_points = [s[b].detach().cpu().numpy() for s in states]
        F_spring, F_friction, F_thrust_left, F_thrust_right = [f[b].detach().cpu().numpy() for f in forces]
        x_grid_np, y_grid_np, z_grid_np = [g[b].detach().cpu().numpy() for g in [x_grid, y_grid, z_grid]]
        mask_left_np, mask_right_np = mask_left[b].detach().cpu().numpy(), mask_right[b].detach().cpu().numpy()

        # set up the visualization
        vis_cfg = setup_visualization(states=(xs, R, xds, omegas, x_points),
                                      forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                                      x_grid=x_grid_np, y_grid=y_grid_np, z_grid=z_grid_np,
                                      mask_left=mask_left_np, mask_right=mask_right_np)

        # visualize animated trajectory
        animate_trajectory(states=(xs, R, xds, omegas, x_points),
                           forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                           z_grid=z_grid_np, mask_left=mask_left_np, mask_right=mask_right_np,
                           vis_cfg=vis_cfg, step=10)


def shoot_multiple():
    from time import time
    from scipy.spatial.transform import Rotation
    from monoforce.models.dphysics import vw_to_track_vel
    from monoforce.vis import set_axes_equal
    import matplotlib.pyplot as plt

    dphys_cfg = DPhysConfig()
    dphys_cfg.traj_sim_time = 5.0

    # simulation parameters
    dt = dphys_cfg.dt
    T = dphys_cfg.traj_sim_time
    num_trajs = 32
    device = 'cpu'

    # rigid body parameters
    x_points = torch.as_tensor(dphys_cfg.robot_points)
    mask_left = torch.as_tensor(dphys_cfg.robot_mask_left)
    mask_right = torch.as_tensor(dphys_cfg.robot_mask_right)

    # initial state
    x = torch.tensor([[-1.0, 0.0, 0.2]]).repeat(num_trajs, 1)
    xd = torch.zeros_like(x)
    # R = torch.eye(3).repeat(x.shape[0], 1, 1)
    R = torch.tensor(Rotation.from_euler('z', np.pi/6).as_matrix(), dtype=torch.float32).repeat(num_trajs, 1, 1)
    omega = torch.zeros_like(x)
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)
    mask_left = mask_left.repeat(x.shape[0], 1)
    mask_right = mask_right.repeat(x.shape[0], 1)

    # heightmap defining the terrain
    x_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    y_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    z_grid = torch.exp(-(x_grid - 2) ** 2 / 4) * torch.exp(-(y_grid - 0) ** 2 / 2)
    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid = z_grid.repeat(x.shape[0], 1, 1)

    # control inputs in Newtons
    assert num_trajs % 2 == 0, 'num_trajs must be even'
    vel_max, omega_max = 1.0, 2 * np.pi
    vels_x = torch.cat([-vel_max * torch.ones((num_trajs // 2, int(T / dt))),
                        vel_max * torch.ones((num_trajs // 2, int(T / dt)))])
    omegas_z = torch.cat([torch.linspace(-omega_max, omega_max, num_trajs // 2),
                          torch.linspace(-omega_max, omega_max, num_trajs // 2)])
    assert vels_x.shape == (num_trajs, int(T / dt))
    assert omegas_z.shape == (num_trajs,)
    vels = torch.zeros((num_trajs, int(T / dt), 3))
    vels[:, :, 0] = vels_x
    omegas = torch.zeros((num_trajs, 3))
    omegas[:, 2] = omegas_z

    controls = torch.zeros((num_trajs, int(T / dt), 2))
    for i in range(num_trajs):
        controls[i, :, 0], controls[i, :, 1] = vw_to_track_vel(vels[i, :, 0], omegas[i, 2])
    controls = dphys_cfg.k_thrust * torch.as_tensor(controls, dtype=torch.float32)

    # initial state
    state0 = (x, xd, R, omega, x_points)

    # put tensors to device
    state0 = tuple([s.to(device) for s in state0])
    z_grid = z_grid.to(device)
    mask_left = mask_left.to(device)
    mask_right = mask_right.to(device)
    controls = controls.to(device)

    # simulate the rigid body dynamics
    with torch.no_grad():
        t0 = time()
        states, forces = dphysics(z_grid=z_grid, controls=controls,
                                  state=state0,
                                  robot_geometry=(mask_left, mask_right),
                                  dphys_cfg=dphys_cfg)
        t1 = time()
        Xs, Xds, Rs, Omegas, X_points = states
        print(Xs.shape)
        print(f'Simulation took {(t1-t0):.3f} [sec] on device: {device}')

    # visualize
    with torch.no_grad():
        fig = plt.figure(figsize=(10, 10))
        ax = fig.add_subplot(111, projection='3d')
        # plot heightmap
        ax.plot_surface(x_grid[0].cpu(), y_grid[0].cpu(), z_grid[0].cpu(), cmap='terrain', alpha=0.6)
        set_axes_equal(ax)
        for i in range(num_trajs):
            ax.plot(Xs[i, :, 0].cpu(), Xs[i, :, 1].cpu(), Xs[i, :, 2].cpu(), c='b')
        ax.set_title(f'Simulation of {num_trajs} trajs (T={T} [sec] long) took {(t1-t0):.3f} [sec] on device: {device}')
        ax.set_xlabel('X [m]')
        ax.set_ylabel('Y [m]')
        ax.set_zlabel('Z [m]')
        plt.show()


def main():
    motion()
    # shoot_multiple()


if __name__ == '__main__':
    main()
