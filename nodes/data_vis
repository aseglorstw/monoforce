#!/usr/bin/env python

import os
import numpy as np
import torch

import rospy
from numpy.lib.recfunctions import unstructured_to_structured
from monoforce.datasets import OmniDEMDataVis, OmniRigidDEMDataVis, robingas_husky_seq_paths
from monoforce.config import Config
from monoforce.ros import height_map_to_gridmap_msg, to_path
from monoforce.models.lss.tools import denormalize_img
from monoforce.models.lss.model import compile_model
from nav_msgs.msg import Path
from sensor_msgs.msg import PointCloud2, Image
from grid_map_msgs.msg import GridMap
from ros_numpy import numpify, msgify
from monoforce.utils import read_yaml
import rospkg


def main():
    rospy.init_node('data_vis', anonymous=True, log_level=rospy.DEBUG)
    cfg = Config()
    pkg_path = rospkg.RosPack().get_path('monoforce')
    config_path = rospy.get_param('~config_path', os.path.join(pkg_path, 'config/dphys_cfg.yaml'))
    assert os.path.isfile(config_path), 'Config file %s does not exist' % config_path
    cfg.from_yaml(config_path)
    cfg.from_rosparams(node_name='data_vis')

    # load LSS config
    lss_config_path = rospy.get_param('~lss_config_path', os.path.join(pkg_path, 'config/lss_cfg.yaml'))
    assert os.path.isfile(lss_config_path), 'LSS config file %s does not exist' % lss_config_path
    lss_config = read_yaml(lss_config_path)
    grid_conf = lss_config['grid_conf']
    data_aug_conf = lss_config['data_aug_conf']

    rate = rospy.get_param('~rate', 1)
    opt_terrain = rospy.get_param('~opt_terrain', False)
    modelf = rospy.get_param('~lss_weights', None)

    # Load traversability data
    path = robingas_husky_seq_paths[rospy.get_param('~seq_i', 0)]
    assert os.path.exists(path)
    Data = OmniRigidDEMDataVis if opt_terrain else OmniDEMDataVis
    ds = Data(path, cfg=cfg, data_aug_conf=data_aug_conf, is_train=False)
    rospy.loginfo('Loaded dataset with %d samples from path: %s' % (len(ds), path))

    # Load model
    if modelf is not None:
        model = compile_model(grid_conf, data_aug_conf, outC=1)
        print('loading', modelf)
        model.load_state_dict(torch.load(modelf, map_location=cfg.device))
        model.eval()

    # Choose data sample
    i = rospy.get_param('~sample_i', np.random.choice(range(len(ds))))
    rospy.loginfo('Using sample %d' % i)
    imgs, rots, trans, intrins, post_rots, post_trans, heightmap, lidar_pts = ds[i]
    traj = ds.get_traj(i)
    poses = traj['poses']
    points = lidar_pts.numpy().T
    if modelf is not None:
        # get heightmap prediction
        inputs = [imgs, rots, trans, intrins, post_rots, post_trans]
        inputs = [torch.as_tensor(i[None], dtype=torch.float64) for i in inputs]
        height = model(*inputs)
        height = height.squeeze().detach().cpu().numpy()
    else:
        height = heightmap[0].numpy()
    height_mask = heightmap[1].numpy()

    # publishing of the data
    gm_pub = rospy.Publisher('grid_map', GridMap, queue_size=1)
    cloud_pub = rospy.Publisher('cloud', PointCloud2, queue_size=1)
    path_pub = rospy.Publisher('path', Path, queue_size=1)
    # image publishers
    img_pubs = [rospy.Publisher('%s/image' % cam.lower(), Image, queue_size=1) for cam in data_aug_conf['cams']]
    assert len(img_pubs) == len(imgs), f'Number of image publishers {len(img_pubs)} does not match number of images {len(imgs)}'

    pub_cloud = rospy.get_param('~pub_cloud', False)
    pub_path = rospy.get_param('~pub_path', False)

    frame = 'base_link'
    rate = rospy.Rate(rate)
    while not rospy.is_shutdown():
        stamp = rospy.Time.now()

        # point cloud
        if pub_cloud:
            points = np.asarray(points, dtype='float32')
            cloud_struct = unstructured_to_structured(points, names=['x', 'y', 'z'])
            cloud_msg = msgify(PointCloud2, cloud_struct)
            cloud_msg.header.frame_id = frame
            cloud_msg.header.stamp = stamp
            cloud_pub.publish(cloud_msg)

        # grid map
        grid_msg = height_map_to_gridmap_msg(height, grid_res=cfg.grid_res, mask=height_mask)
        grid_msg.info.header.frame_id = frame
        grid_msg.info.header.stamp = stamp
        gm_pub.publish(grid_msg)

        # path
        if pub_path:
            path_msg = to_path(poses, frame_id=frame, stamp=stamp)
            path_pub.publish(path_msg)

        # images
        for img, pub in zip(imgs, img_pubs):
            img = denormalize_img(img)
            img = np.asarray(img, dtype='uint8')
            img_msg = msgify(Image, img, encoding='rgb8')
            img_msg.header.stamp = stamp
            pub.publish(img_msg)

        rospy.logdebug('Published data')
        rate.sleep()


if __name__ == '__main__':
    main()
