#! /usr/bin/env python3
import os
import torch
from pytorch3d.loss import (
        chamfer_distance,
        mesh_edge_loss,
        mesh_laplacian_smoothing,
        mesh_normal_consistency,
    )
from pytorch3d.structures import Meshes, Pointclouds
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader
from tqdm import tqdm
from monoforce.cloudproc import hm_to_cloud
from monoforce.datasets.data import TravData, explore_data
from monoforce.datasets.data import seq_paths
from monoforce.config import Config
from monoforce.models.lss.tools import ego_to_cam, get_only_in_img_mask
from monoforce.transformations import transform_cloud
from monoforce.utils import read_yaml
from monoforce.models.lss.model import compile_model
from monoforce.losses import total_variation
import matplotlib as mpl
import open3d as o3d
# mpl.use('Qt5Agg')


torch.set_default_dtype(torch.float32)

def feed_data():
    path = '/media/ruslan/data/husky_sim/husky_back_forth_rigid_soft_cubes_2024-02-15-15-07-56/'

    # lss model
    cfg = Config()
    cfg.from_yaml('../config/cfg.yaml')

    # load LSS config
    lss_config = read_yaml('../config/lss.yaml')
    grid_conf, data_aug_conf = lss_config['grid_conf'], lss_config['data_aug_conf']
    # explore_data(path, grid_conf, data_aug_conf, cfg, is_train=False)

    ds = TravData(path, data_aug_conf, is_train=False, cfg=cfg)
    loader = torch.utils.data.DataLoader(ds, batch_size=1, shuffle=False)
    model = compile_model(grid_conf, data_aug_conf, outC=1)
    model.train()
    model.to(cfg.device)

    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
    criterion = torch.nn.MSELoss()
    max_grad_norm = 5.0

    # train on a single example
    sample_i = np.random.randint(len(ds))
    imgs, rots, trans, intrins, post_rots, post_trans, hm_lidar, hm_traj, map_pose = ds[sample_i]
    inputs = [imgs, rots, trans, intrins, post_rots, post_trans]
    inputs = [s[np.newaxis].to(cfg.device) for s in inputs]

    hm_lidar = torch.as_tensor(hm_lidar[np.newaxis], device=cfg.device)
    height_lidar, mask_lidar = hm_lidar[:, 0:1], hm_lidar[:, 1:2]

    hm_traj = torch.as_tensor(hm_traj[np.newaxis], device=cfg.device)
    height_traj, mask_traj = hm_traj[:, 0:1], hm_traj[:, 1:2]

    losses = {'lidar': [], 'traj': [], 'total': []}
    for i in tqdm(range(501)):
        voxel_feats = model.get_voxels(*inputs)
        height_pred_geom, height_pred_diff = model.bevencode(voxel_feats)
        height_pred_rigid = height_pred_geom - height_pred_diff

        loss_lidar = criterion(height_pred_geom[mask_lidar.bool()], height_lidar[mask_lidar.bool()])
        loss_traj = 100 * criterion(height_pred_rigid[mask_traj.bool()], height_traj[mask_traj.bool()])

        # loss_reg = 0.01 * total_variation(height_pred)
        loss = loss_lidar + loss_traj

        # print(loss_lidar.item(), loss_traj.item(), loss.item())
        losses['lidar'].append(loss_lidar.item())
        losses['traj'].append(loss_traj.item())
        losses['total'].append(loss.item())

        optimizer.zero_grad()
        loss.backward()
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_grad_norm)
        optimizer.step()

        if i % 100 == 0:
            # plot the result
            plt.figure(figsize=(20, 5))
            plt.subplot(2, 3, 1)
            plt.title('Lidar HM')
            plt.imshow(height_lidar[0, 0].cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 2)
            plt.title('Traj HM')
            plt.imshow(height_traj[0, 0].cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.subplot(2, 3, 3)
            plt.title('Loss')
            for k, v in losses.items():
                plt.plot(v[-100:], label=k)
            plt.legend()

            plt.subplot(2, 3, 4)
            plt.title('Prediction Geom')
            plt.imshow(height_pred_geom[0, 0].detach().cpu().numpy().T, cmap='jet', vmin=-1, vmax=1, origin='lower')
            plt.colorbar()

            plt.show()


def map_consistency():
    cfg_path = '../config/tb_runs/lss_2024_01_26_15_07_31/cfg.yaml'
    lss_cfg_path = '../config/tb_runs/lss_2024_01_26_15_07_31/lss.yaml'
    model_path = '../config/tb_runs/lss_2024_01_26_15_07_31/train_lss.pt'

    cfg = Config()
    cfg.from_yaml(cfg_path)
    cfg.hm_interp_method = None
    cfg.device = 'cuda'

    predicted_map = True
    vis = True

    lss_cfg = read_yaml(lss_cfg_path)
    data_aug_conf = lss_cfg['data_aug_conf']
    grid_conf = lss_cfg['grid_conf']

    ds = TravData(seq_paths[0], is_train=True, data_aug_conf=data_aug_conf, cfg=cfg)
    loader = DataLoader(ds, batch_size=16, shuffle=False)
    # ds.global_cloud(vis=True)
    ds.global_hm_cloud(vis=True)

    model = compile_model(grid_conf, data_aug_conf, outC=1)
    model.load_state_dict(torch.load(model_path))
    model.eval()
    model.to(cfg.device)

    # create global heightmap
    for batch in tqdm(loader):
        with torch.no_grad():
            batch = [torch.as_tensor(b, dtype=torch.float32, device=cfg.device) for b in batch]
            imgs, rots, trans, intrins, post_rots, post_trans, hm_lidar, hm_traj, map_pose = batch

            if predicted_map:
                inputs = [imgs, rots, trans, intrins, post_rots, post_trans]
                height_pred = model(*inputs)
                height = height_pred
                # mask = torch.ones_like(height)
                mask = hm_lidar[:, 1:2]
            else:
                height = hm_lidar[:, 0:1]
                mask = hm_lidar[:, 1:2]

            global_hm_clouds = []
            for p, h, m in zip(map_pose, height, mask):
                hm_cloud = hm_to_cloud(h.squeeze(), cfg, mask=m.squeeze())
                hm_cloud = transform_cloud(hm_cloud, p)
                global_hm_clouds.append(hm_cloud)

            # pytorch3d pointcloud
            src_cloud = Pointclouds(points=[torch.cat(global_hm_clouds[::2])])
            tgt_cloud = Pointclouds(points=[torch.cat(global_hm_clouds[1::2])])
            # chamfer distance
            chamfer_dist, _ = chamfer_distance(src_cloud, tgt_cloud)
            print('Chamfer distance:', chamfer_dist)

            if vis:
                global_hm_cloud = torch.cat(global_hm_clouds, dim=0)
                # plot global cloud with open3d
                hm_pcd = o3d.geometry.PointCloud()
                hm_pcd.points = o3d.utility.Vector3dVector(global_hm_cloud.cpu().numpy())
                o3d.visualization.draw_geometries([hm_pcd])


def data_slicing():
    cfg = Config()
    cfg.from_yaml('../config/cfg.yaml')

    lss_cfg = read_yaml('../config/lss.yaml')
    data_aug_conf = lss_cfg['data_aug_conf']
    grid_conf = lss_cfg['grid_conf']

    ds = TravData(seq_paths[0], is_train=True, data_aug_conf=data_aug_conf, cfg=cfg)
    ds_slice = ds[150:200]
    print("Full dataset contains samples", ds.ids)
    print("Sliced dataset contains samples", ds_slice.ids)
    # check if sliced dataset indixes is a subset of full dataset indixes
    assert set(ds_slice.ids).issubset(set(ds.ids))
    ds_slice.global_hm_cloud(vis=True)


def main():
    feed_data()
    # map_consistency()
    # data_slicing()


if __name__ == '__main__':
    main()
