#!/usr/bin/env python

import os
import numpy as np
import torch
import rospy
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
from monoforce.datasets import RobinGasDataset
from monoforce.segmentation import position
from monoforce.vis import set_axes_equal
from monoforce.models import make_dphysics_model
from monoforce.transformations import transform_cloud
from monoforce.config import Config
from monoforce.ros import height_map_to_point_cloud_msg, height_map_to_gridmap_msg
from sensor_msgs.msg import PointCloud2
from grid_map_msgs.msg import GridMap
from ros_numpy import numpify, msgify
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.transform import Rotation

torch.set_default_dtype(torch.float64)


def demo():
    rospy.init_node('data_vis', anonymous=True, log_level=rospy.DEBUG)
    # at the moment, config requires ROS to be initialized
    cfg = Config()
    cfg.from_rosparams(node_name='data_vis')
    rate = rospy.get_param('~rate', 1)

    # Load traversability data
    path = '/home/ruslan/data/bags/robingas/data/22-08-12-cimicky_haj/marv/ugv_2022-08-12-15-18-34_trav/'
    assert os.path.exists(path)
    ds = RobinGasDataset(path, cfg=cfg)
    print('Dataset contains %i samples' % len(ds))

    # Choose data sample
    # i = np.random.choice(range(len(ds)))
    i = 0
    cloud, traj, height = ds[i]
    poses = traj['poses']
    points = position(cloud)

    # # Transform point cloud to robot frame
    # Tr = np.eye(4)
    # Tr[:3, :3] = Rotation.from_euler('z', angles=45, degrees=True).as_matrix()
    # Tr[3, 3] = 0.7
    # points = transform_cloud(points, Tr)
    # # Transform poses to robot frame
    # poses = np.asarray([np.matmul(Tr, pose) for pose in poses])

    with torch.no_grad():
        system_true = make_dphysics_model(height['z'], cfg)

        t0, state = 0., system_true.state
        tt = torch.linspace(float(t0), cfg.total_sim_time, cfg.n_samples)
        x_true = system_true.sim(state, tt)

        pos_x, pos_R, vel_x, vel_omega, forces = x_true
        poses_sim = torch.cat([pos_R, pos_x], dim=-1)  # (n_samples, 3, 4)

    # Visualization of the data
    fig = plt.figure(figsize=(24, 12))
    ax = fig.add_subplot(121, projection='3d')
    ax.plot_surface(height['x'], height['y'], height['z'], alpha=0.7)
    ax.plot(points[:, 0], points[:, 1], points[:, 2], '.', color='k', markersize=1.)
    ax.plot(poses[:, 0, 3], poses[:, 1, 3], poses[:, 2, 3], 'ro', markersize=2)
    ax.plot(poses_sim[:, 0, 3], poses_sim[:, 1, 3], poses_sim[:, 2, 3], 'go', markersize=2)
    ax.set_xlabel('X Label')
    ax.set_ylabel('Y Label')
    ax.set_zlabel('Z Label')
    set_axes_equal(ax)

    ax = fig.add_subplot(122)
    CS = plt.contour(height['x'], height['y'], height['z'], 15, linewidths=0.11, colors='k')
    CS = plt.contourf(height['x'], height['y'], height['z'], 15, cmap=plt.cm.jet)
    plt.colorbar(CS)
    ax.axis('equal')
    plt.show()

    # publishing of the data
    gm_pub = rospy.Publisher('grid_map', GridMap, queue_size=1)
    cloud_pub = rospy.Publisher('cloud', PointCloud2, queue_size=1)
    frame = 'sensor_frame'
    rate = rospy.Rate(rate)
    while not rospy.is_shutdown():
        stamp = rospy.Time.now()

        # point cloud
        points = np.asarray(points, dtype='float32')
        cloud_struct = unstructured_to_structured(points, names=['x', 'y', 'z'])
        cloud_msg = msgify(PointCloud2, cloud_struct)
        cloud_msg.header.frame_id = frame
        cloud_msg.header.stamp = stamp

        # grid map
        grid_msg = height_map_to_gridmap_msg(height['z'], grid_res=cfg.grid_res)
        grid_msg.info.header.frame_id = frame
        grid_msg.info.header.stamp = stamp

        cloud_pub.publish(cloud_msg)
        gm_pub.publish(grid_msg)

        rospy.logdebug('Published data')
        rate.sleep()


def main():
    demo()


if __name__ == '__main__':
    main()
