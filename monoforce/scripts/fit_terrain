import torch
import numpy as np
from monoforce.models.dphysics import dphysics
from monoforce.config import DPhysConfig
from monoforce.monoforce.scripts.robot_control import shoot_multiple
from monoforce.vis import setup_visualization, animate_trajectory


def visualize(states, forces, x_grid, y_grid, z_grid, mask_left, mask_right):
    with torch.no_grad():
        # visualize using mayavi
        for b in range(len(states[0])):
            # get the states and forces for the b-th rigid body and move them to the cpu
            xs, R, xds, omegas, x_points = [s[b].cpu().numpy() for s in states]
            F_spring, F_friction, F_thrust_left, F_thrust_right = [f[b].cpu().numpy() for f in forces]
            x_grid_np, y_grid_np, z_grid_np = [g[b].cpu().numpy() for g in [x_grid, y_grid, z_grid]]
            mask_left_np, mask_right_np = mask_left[b].cpu().numpy(), mask_right[b].cpu().numpy()

            # set up the visualization
            vis_cfg = setup_visualization(states=(xs, R, xds, omegas, x_points),
                                          forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                                          x_grid=x_grid_np, y_grid=y_grid_np, z_grid=z_grid_np,
                                          mask_left=mask_left_np, mask_right=mask_right_np)

            # visualize animated trajectory
            animate_trajectory(states=(xs, R, xds, omegas, x_points),
                               forces=(F_spring, F_friction, F_thrust_left, F_thrust_right),
                               z_grid=z_grid_np,
                               mask_left=mask_left_np, mask_right=mask_right_np,
                               vis_cfg=vis_cfg, step=10)


def optimization():
    dphys_cfg = DPhysConfig()

    # simulation parameters
    dt = 0.01
    T = 5.0
    n_iters = 100
    lr = 0.002

    # rigid body parameters
    x_points = torch.as_tensor(dphys_cfg.robot_points)
    mask_left = torch.as_tensor(dphys_cfg.robot_mask_left)
    mask_right = torch.as_tensor(dphys_cfg.robot_mask_right)

    # initial state
    x = torch.tensor([
        [-2.0, 0.0, 1.0]
    ])
    xd = torch.tensor([
        [0.0, 0.0, 0.0]
    ])
    R = torch.eye(3).repeat(x.shape[0], 1, 1)
    omega = torch.tensor([
        [0.0, 0.0, 0.0]
    ])
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)
    mask_left = mask_left.repeat(x.shape[0], 1)
    mask_right = mask_right.repeat(x.shape[0], 1)

    # heightmap defining the terrain
    x_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    y_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    z_grid_gt = torch.exp(-(x_grid) ** 2 / 4) * torch.exp(-(y_grid - 2) ** 2 / 2)
    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid_gt = z_grid_gt.repeat(x.shape[0], 1, 1)

    # control inputs in Newtons
    controls = torch.tensor([
        [[110.0, 110.0]] * int(T / dt)
    ])

    # initial state
    state0 = (x, xd, R, omega, x_points)

    # simulate the rigid body dynamics
    states_gt, forces_gt = dphysics(z_grid=z_grid_gt, controls=controls, state=state0, dphys_cfg=dphys_cfg)
    visualize(states_gt, forces_gt, x_grid, y_grid, z_grid_gt, mask_left, mask_right)

    # initial guess for the heightmap
    z_grid = torch.zeros_like(z_grid_gt, requires_grad=True)

    # optimization
    optimizer = torch.optim.Adam([z_grid], lr=lr)
    z_grid_best = z_grid.clone()
    loss_best = np.inf
    for i in range(n_iters):
        optimizer.zero_grad()
        # simulate the rigid body dynamics
        states, forces = dphysics(z_grid=z_grid, controls=controls, state=state0, dphys_cfg=dphys_cfg)

        # unpack the states
        Xs, Xds, Rs, Omegas, X_points = states
        Xs_gt, Xds_gt, Rs_gt, Omegas_gt, X_points_gt = states_gt

        # compute the loss
        loss_x = torch.nn.functional.mse_loss(Xs, Xs_gt)
        loss_xd = torch.nn.functional.mse_loss(Xds, Xds_gt)
        loss = loss_x + loss_xd
        loss.backward()
        optimizer.step()
        print(f'Iteration {i}, Loss x: {loss_x.item():.3f}, Loss xd: {loss_xd.item():.3f}')

        if loss.item() < loss_best:
            loss_best = loss.item()
            z_grid_best = z_grid.clone()

        # heightmap difference
        with torch.no_grad():
            z_diff = torch.nn.functional.mse_loss(z_grid, z_grid_gt)
            print(f'Heightmap difference: {z_diff.item()}')

        # visualize the optimized heightmap
        visualize(states, forces, x_grid, y_grid, z_grid_best, mask_left, mask_right)


def terrain_properties():
    from monoforce.models.dphysics import interpolate_height

    dphys_cfg = DPhysConfig()
    dphys_cfg.k_stiffness = 10_000.
    dphys_cfg.traj_sim_time = 5.0

    # simulation parameters
    dt = dphys_cfg.dt
    T = dphys_cfg.traj_sim_time
    n_iters = 100
    lr = 0.1

    # rigid body parameters
    x_points = torch.as_tensor(dphys_cfg.robot_points)
    mask_left = torch.as_tensor(dphys_cfg.robot_mask_left)
    mask_right = torch.as_tensor(dphys_cfg.robot_mask_right)

    # initial state
    x = torch.tensor([[-2.0, 0.0, 0.2]])
    xd = torch.tensor([[0.0, 0.0, 0.0]])
    R = torch.eye(3).repeat(x.shape[0], 1, 1)
    omega = torch.tensor([[0.0, 0.0, 0.0]])
    x_points = x_points @ R.transpose(1, 2) + x.unsqueeze(1)

    # heightmap defining the terrain
    x_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    y_grid = torch.arange(-dphys_cfg.d_max, dphys_cfg.d_max, dphys_cfg.grid_res)
    x_grid, y_grid = torch.meshgrid(x_grid, y_grid)
    z_grid = torch.exp(-(x_grid) ** 2 / 4) * torch.exp(-(y_grid - 2) ** 2 / 2)
    # repeat the heightmap for each rigid body
    x_grid = x_grid.repeat(x.shape[0], 1, 1)
    y_grid = y_grid.repeat(x.shape[0], 1, 1)
    z_grid = z_grid.repeat(x.shape[0], 1, 1)

    # repeat the rigid body parameters for each rigid body
    mask_left = mask_left.repeat(x.shape[0], 1)
    mask_right = mask_right.repeat(x.shape[0], 1)

    # control inputs in Newtons
    controls = 170. * torch.tensor([[[1.0, 1.0]] * int(T / dt)])

    # initial state
    state0 = (x, xd, R, omega, x_points)

    # simulate the rigid body dynamics
    states_gt, forces_gt = dphysics(z_grid=z_grid, controls=controls, state=state0, dphys_cfg=dphys_cfg)
    z_gt = interpolate_height(z_grid, states_gt[0][..., 0], states_gt[0][..., 1],
                              d_max=dphys_cfg.d_max, grid_res=dphys_cfg.grid_res)
    states_gt[0][..., 2] = z_gt
    # visualize(states_gt, forces_gt, x_grid, y_grid, z_grid, mask_left, mask_right)

    # optimization
    dphys_cfg.k_stiffness = torch.tensor([dphys_cfg.k_stiffness], requires_grad=True)
    optimizer = torch.optim.Adam([dphys_cfg.k_stiffness], lr=lr)
    for i in range(n_iters):
        optimizer.zero_grad()
        # simulate the rigid body dynamics
        states, forces = dphysics(z_grid=z_grid, controls=controls, state=state0, dphys_cfg=dphys_cfg)
        # compute the loss
        Xs, Xs_gt = states[0], states_gt[0]
        loss = torch.nn.functional.mse_loss(Xs, Xs_gt)
        loss.backward()
        optimizer.step()
        print(f'Iteration {i}, Loss: {loss}, k_stiffness: {dphys_cfg.k_stiffness.item()}')

        if i % 10 == 0:
            visualize(states, forces, x_grid, y_grid, z_grid, mask_left, mask_right)


def main():
    optimization()
    # terrain_properties()


if __name__ == '__main__':
    main()
